<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Spy Game</title>
<style>
    body {
        font-family: Arial, sans-serif;
        background: #111;
        color: #fff;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
    }
    .container {
        background: #1e1e1e;
        padding: 25px;
        border-radius: 10px;
        width: 320px;
        text-align: center;
    }
    .player {
        background: #2a2a2a;
        margin: 10px 0;
        padding: 12px;
        border-radius: 8px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .word {
        display: none;
        font-weight: bold;
        color: #00ffcc;
    }
    button {
        background: none;
        border: none;
        color: #fff;
        font-size: 20px;
        cursor: pointer;
    }
</style>
</head>
<body>

<div class="container">
    <h2>üïµÔ∏è Spy Game</h2>

    <div class="player">
        <span>Shawn</span>
        <span class="word" id="w1"></span>
        <button onclick="toggleWord('w1')">üëÅ</button>
    </div>

    <div class="player">
        <span>Saniel</span>
        <span class="word" id="w2"></span>
        <button onclick="toggleWord('w2')">üëÅ</button>
    </div>

    <div class="player">
        <span>Melita</span>
        <span class="word" id="w3"></span>
        <button onclick="toggleWord('w3')">üëÅ</button>
    </div>
</div>

<script>
    // 100 word combinations (3 words each)
    const combinations = [
        ["Apple", "Apple", "Spy"],
        ["Beach", "Beach", "Spy"],
        ["Doctor", "Doctor", "Spy"],
        ["School", "School", "Spy"],
        ["Cinema", "Cinema", "Spy"],
        ["Airport", "Airport", "Spy"],
        ["Hotel", "Hotel", "Spy"],
        ["Hospital", "Hospital", "Spy"],
        ["Mall", "Mall", "Spy"],
        ["Restaurant", "Restaurant", "Spy"],
    ];

    // Expand to 100 automatically
    while (combinations.length < 100) {
        combinations.push(...combinations.slice(0, 10));
    }

    // Pick random combination
    const selected = combinations[Math.floor(Math.random() * combinations.length)];

    // Shuffle words
    selected.sort(() => Math.random() - 0.5);

    document.getElementById("w1").innerText = selected[0];
    document.getElementById("w2").innerText = selected[1];
    document.getElementById("w3").innerText = selected[2];

    function toggleWord(id) {
        const el = document.getElementById(id);
        el.style.display = el.style.display === "none" ? "inline" : "none";
    }
</script>

</body>
</html>      flex-direction: column;
      color: #fff;
      z-index: 9;
    }
    #instructions {
      text-align: center;
      max-width: 520px;
      cursor: pointer;
    }
    #instructions h1 {
      margin-bottom: 8px;
      font-size: 24px;
    }
    #instructions p {
      margin: 4px 0;
      font-size: 14px;
      color: #ddd;
    }
    #instructions span {
      font-weight: 600;
      color: #ffd95e;
    }
  </style>
</head>
<body>
  <div id="info">
    Mini City Sandbox ‚Äì WASD to move, Mouse to look, Shift = sprint, Space = jump
  </div>
  <div id="blocker">
    <div id="instructions">
      <h1>Click to Enter the City</h1>
      <p>Move with <span>W A S D</span></p>
      <p>Look around with your <span>mouse</span></p>
      <p><span>Shift</span> to sprint, <span>Space</span> to jump</p>
      <p style="margin-top:10px; font-size:12px; color:#aaa;">
        (This is a simple GTA-style sandbox made with Three.js ‚Äì no missions, just explore!)
      </p>
    </div>
  </div>

  <!-- Three.js + PointerLockControls from CDN -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.160.0/examples/js/controls/PointerLockControls.js"></script>

  <script>
    // Basic three.js variables
    let camera, scene, renderer, controls;
    let moveForward = false;
    let moveBackward = false;
    let moveLeft = false;
    let moveRight = false;
    let canJump = false;
    let sprint = false;

    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();

    let prevTime = performance.now();

    init();
    animate();

    function init() {
      const blocker = document.getElementById("blocker");
      const instructions = document.getElementById("instructions");

      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x050816);
      scene.fog = new THREE.Fog(0x050816, 50, 400);

      // Camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      // Lights ‚Äì city vibe
      const hemiLight = new THREE.HemisphereLight(0x66aaff, 0x222233, 0.6);
      hemiLight.position.set(0, 200, 0);
      scene.add(hemiLight);

      const dirLight = new THREE.DirectionalLight(0xffddaa, 0.8);
      dirLight.position.set(-50, 100, 30);
      scene.add(dirLight);

      // Pointer lock controls
      controls = new THREE.PointerLockControls(camera, document.body);

      instructions.addEventListener("click", function () {
        controls.lock();
      });

      controls.addEventListener("lock", function () {
        blocker.style.display = "none";
      });

      controls.addEventListener("unlock", function () {
        blocker.style.display = "flex";
      });

      scene.add(controls.getObject());
      controls.getObject().position.set(0, 10, 40); // starting position

      // Terrain (road + pavements)
      const groundGeo = new THREE.PlaneGeometry(600, 600);
      const groundMat = new THREE.MeshPhongMaterial({ color: 0x20232a, depthWrite: true });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Simple road grid
      const roadMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
      const laneMat = new THREE.MeshBasicMaterial({ color: 0xf4f4f4 });
      for (let i = -250; i <= 250; i += 80) {
        const road = new THREE.Mesh(new THREE.PlaneGeometry(600, 20), roadMat);
        road.rotation.x = -Math.PI / 2;
        road.position.z = i;
        scene.add(road);

        const road2 = new THREE.Mesh(new THREE.PlaneGeometry(20, 600), roadMat);
        road2.rotation.x = -Math.PI / 2;
        road2.position.x = i;
        scene.add(road2);
      }

      // Buildings (random boxes)
      const buildingColors = [0x203060, 0x304070, 0x401f6b, 0x274060, 0x2b3a67];
      const buildingGeo = new THREE.BoxGeometry(20, 20, 20);

      for (let x = -220; x <= 220; x += 40) {
        for (let z = -220; z <= 220; z += 40) {
          // Skip near centre roads (to keep open space)
          if (Math.abs(x) < 40 || Math.abs(z) < 40) continue;
          if (Math.abs(x) < 80 && Math.abs(z) < 80) continue;

          const height = 20 + Math.random() * 80;
          const geo = new THREE.BoxGeometry(20, height, 20);
          const color = buildingColors[Math.floor(Math.random() * buildingColors.length)];
          const mat = new THREE.MeshPhongMaterial({
            color,
            emissive: 0x050505,
            shininess: 30
          });
          const building = new THREE.Mesh(geo, mat);
          building.position.set(x, height / 2, z);
          building.castShadow = true;
          building.receiveShadow = true;
          scene.add(building);

          // Simple "windows" as smaller emissive cubes on some
          if (Math.random() > 0.6) {
            const winGeo = new THREE.BoxGeometry(18, height * 0.8, 0.5);
            const winMat = new THREE.MeshBasicMaterial({ color: 0xfff4cc });
            const windows = new THREE.Mesh(winGeo, winMat);
            windows.position.set(x, height / 2, z + 10.3);
            scene.add(windows);
          }
        }
      }

      // Small props (cars as rectangles)
      const carGeo = new THREE.BoxGeometry(8, 3, 14);
      const carColors = [0xff5555, 0x55ffcc, 0xffee55, 0x9999ff];
      for (let i = 0; i < 25; i++) {
        const mat = new THREE.MeshPhongMaterial({
          color: carColors[Math.floor(Math.random() * carColors.length)]
        });
        const car = new THREE.Mesh(carGeo, mat);
        const angle = Math.random() * Math.PI * 2;
        const radius = 40 + Math.random() * 200;
        car.position.set(Math.cos(angle) * radius, 1.5, Math.sin(angle) * radius);
        car.rotation.y = Math.random() * Math.PI * 2;
        scene.add(car);
      }

      // Event listeners
      const onKeyDown = function (event) {
        switch (event.code) {
          case "ArrowUp":
          case "KeyW":
            moveForward = true;
            break;
          case "ArrowLeft":
          case "KeyA":
            moveLeft = true;
            break;
          case "ArrowDown":
          case "KeyS":
            moveBackward = true;
            break;
          case "ArrowRight":
          case "KeyD":
            moveRight = true;
            break;
          case "Space":
            if (canJump === true) {
              velocity.y += 250;
              canJump = false;
            }
            break;
          case "ShiftLeft":
          case "ShiftRight":
            sprint = true;
            break;
        }
      };

      const onKeyUp = function (event) {
        switch (event.code) {
          case "ArrowUp":
          case "KeyW":
            moveForward = false;
            break;
          case "ArrowLeft":
          case "KeyA":
            moveLeft = false;
            break;
          case "ArrowDown":
          case "KeyS":
            moveBackward = false;
            break;
          case "ArrowRight":
          case "KeyD":
            moveRight = false;
            break;
          case "ShiftLeft":
          case "ShiftRight":
            sprint = false;
            break;
        }
      };

      document.addEventListener("keydown", onKeyDown);
      document.addEventListener("keyup", onKeyUp);

      window.addEventListener("resize", onWindowResize);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);

      const time = performance.now();

      if (controls.isLocked === true) {
        const delta = (time - prevTime) / 1000;

        // damping
        velocity.x -= velocity.x * 8.0 * delta;
        velocity.z -= velocity.z * 8.0 * delta;

        // gravity
        velocity.y -= 9.8 * 50.0 * delta;

        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize(); // consistent movement speed

        const baseSpeed = sprint ? 600.0 : 400.0;

        if (moveForward || moveBackward) velocity.z -= direction.z * baseSpeed * delta;
        if (moveLeft || moveRight)   velocity.x -= direction.x * baseSpeed * delta;

        controls.moveRight(-velocity.x * delta);
        controls.moveForward(-velocity.z * delta);

        controls.getObject().position.y += velocity.y * delta;

        // Simple ground collision (y=10)
        if (controls.getObject().position.y < 10) {
          velocity.y = 0;
          controls.getObject().position.y = 10;
          canJump = true;
        }
      }

      prevTime = time;

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>


