<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mini City Sandbox (WASD + Mouse + Shift + Space)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      background: #000;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: #fff;
      background: rgba(0,0,0,0.6);
      padding: 8px 14px;
      border-radius: 999px;
      font-size: 13px;
      z-index: 10;
      pointer-events: none;
      text-align: center;
    }
    #blocker {
      position: absolute;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      color: #fff;
      z-index: 9;
    }
    #instructions {
      text-align: center;
      max-width: 520px;
      cursor: pointer;
    }
    #instructions h1 {
      margin-bottom: 8px;
      font-size: 24px;
    }
    #instructions p {
      margin: 4px 0;
      font-size: 14px;
      color: #ddd;
    }
    #instructions span {
      font-weight: 600;
      color: #ffd95e;
    }
  </style>
</head>
<body>
  <div id="info">
    Mini City Sandbox – WASD to move, Mouse to look, Shift = sprint, Space = jump
  </div>
  <div id="blocker">
    <div id="instructions">
      <h1>Click to Enter the City</h1>
      <p>Move with <span>W A S D</span></p>
      <p>Look around with your <span>mouse</span></p>
      <p><span>Shift</span> to sprint, <span>Space</span> to jump</p>
      <p style="margin-top:10px; font-size:12px; color:#aaa;">
        (This is a simple GTA-style sandbox made with Three.js – no missions, just explore!)
      </p>
    </div>
  </div>

  <!-- Three.js + PointerLockControls from CDN -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.160.0/examples/js/controls/PointerLockControls.js"></script>

  <script>
    // Basic three.js variables
    let camera, scene, renderer, controls;
    let moveForward = false;
    let moveBackward = false;
    let moveLeft = false;
    let moveRight = false;
    let canJump = false;
    let sprint = false;

    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();

    let prevTime = performance.now();

    init();
    animate();

    function init() {
      const blocker = document.getElementById("blocker");
      const instructions = document.getElementById("instructions");

      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x050816);
      scene.fog = new THREE.Fog(0x050816, 50, 400);

      // Camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      // Lights – city vibe
      const hemiLight = new THREE.HemisphereLight(0x66aaff, 0x222233, 0.6);
      hemiLight.position.set(0, 200, 0);
      scene.add(hemiLight);

      const dirLight = new THREE.DirectionalLight(0xffddaa, 0.8);
      dirLight.position.set(-50, 100, 30);
      scene.add(dirLight);

      // Pointer lock controls
      controls = new THREE.PointerLockControls(camera, document.body);

      instructions.addEventListener("click", function () {
        controls.lock();
      });

      controls.addEventListener("lock", function () {
        blocker.style.display = "none";
      });

      controls.addEventListener("unlock", function () {
        blocker.style.display = "flex";
      });

      scene.add(controls.getObject());
      controls.getObject().position.set(0, 10, 40); // starting position

      // Terrain (road + pavements)
      const groundGeo = new THREE.PlaneGeometry(600, 600);
      const groundMat = new THREE.MeshPhongMaterial({ color: 0x20232a, depthWrite: true });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Simple road grid
      const roadMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
      const laneMat = new THREE.MeshBasicMaterial({ color: 0xf4f4f4 });
      for (let i = -250; i <= 250; i += 80) {
        const road = new THREE.Mesh(new THREE.PlaneGeometry(600, 20), roadMat);
        road.rotation.x = -Math.PI / 2;
        road.position.z = i;
        scene.add(road);

        const road2 = new THREE.Mesh(new THREE.PlaneGeometry(20, 600), roadMat);
        road2.rotation.x = -Math.PI / 2;
        road2.position.x = i;
        scene.add(road2);
      }

      // Buildings (random boxes)
      const buildingColors = [0x203060, 0x304070, 0x401f6b, 0x274060, 0x2b3a67];
      const buildingGeo = new THREE.BoxGeometry(20, 20, 20);

      for (let x = -220; x <= 220; x += 40) {
        for (let z = -220; z <= 220; z += 40) {
          // Skip near centre roads (to keep open space)
          if (Math.abs(x) < 40 || Math.abs(z) < 40) continue;
          if (Math.abs(x) < 80 && Math.abs(z) < 80) continue;

          const height = 20 + Math.random() * 80;
          const geo = new THREE.BoxGeometry(20, height, 20);
          const color = buildingColors[Math.floor(Math.random() * buildingColors.length)];
          const mat = new THREE.MeshPhongMaterial({
            color,
            emissive: 0x050505,
            shininess: 30
          });
          const building = new THREE.Mesh(geo, mat);
          building.position.set(x, height / 2, z);
          building.castShadow = true;
          building.receiveShadow = true;
          scene.add(building);

          // Simple "windows" as smaller emissive cubes on some
          if (Math.random() > 0.6) {
            const winGeo = new THREE.BoxGeometry(18, height * 0.8, 0.5);
            const winMat = new THREE.MeshBasicMaterial({ color: 0xfff4cc });
            const windows = new THREE.Mesh(winGeo, winMat);
            windows.position.set(x, height / 2, z + 10.3);
            scene.add(windows);
          }
        }
      }

      // Small props (cars as rectangles)
      const carGeo = new THREE.BoxGeometry(8, 3, 14);
      const carColors = [0xff5555, 0x55ffcc, 0xffee55, 0x9999ff];
      for (let i = 0; i < 25; i++) {
        const mat = new THREE.MeshPhongMaterial({
          color: carColors[Math.floor(Math.random() * carColors.length)]
        });
        const car = new THREE.Mesh(carGeo, mat);
        const angle = Math.random() * Math.PI * 2;
        const radius = 40 + Math.random() * 200;
        car.position.set(Math.cos(angle) * radius, 1.5, Math.sin(angle) * radius);
        car.rotation.y = Math.random() * Math.PI * 2;
        scene.add(car);
      }

      // Event listeners
      const onKeyDown = function (event) {
        switch (event.code) {
          case "ArrowUp":
          case "KeyW":
            moveForward = true;
            break;
          case "ArrowLeft":
          case "KeyA":
            moveLeft = true;
            break;
          case "ArrowDown":
          case "KeyS":
            moveBackward = true;
            break;
          case "ArrowRight":
          case "KeyD":
            moveRight = true;
            break;
          case "Space":
            if (canJump === true) {
              velocity.y += 250;
              canJump = false;
            }
            break;
          case "ShiftLeft":
          case "ShiftRight":
            sprint = true;
            break;
        }
      };

      const onKeyUp = function (event) {
        switch (event.code) {
          case "ArrowUp":
          case "KeyW":
            moveForward = false;
            break;
          case "ArrowLeft":
          case "KeyA":
            moveLeft = false;
            break;
          case "ArrowDown":
          case "KeyS":
            moveBackward = false;
            break;
          case "ArrowRight":
          case "KeyD":
            moveRight = false;
            break;
          case "ShiftLeft":
          case "ShiftRight":
            sprint = false;
            break;
        }
      };

      document.addEventListener("keydown", onKeyDown);
      document.addEventListener("keyup", onKeyUp);

      window.addEventListener("resize", onWindowResize);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);

      const time = performance.now();

      if (controls.isLocked === true) {
        const delta = (time - prevTime) / 1000;

        // damping
        velocity.x -= velocity.x * 8.0 * delta;
        velocity.z -= velocity.z * 8.0 * delta;

        // gravity
        velocity.y -= 9.8 * 50.0 * delta;

        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize(); // consistent movement speed

        const baseSpeed = sprint ? 600.0 : 400.0;

        if (moveForward || moveBackward) velocity.z -= direction.z * baseSpeed * delta;
        if (moveLeft || moveRight)   velocity.x -= direction.x * baseSpeed * delta;

        controls.moveRight(-velocity.x * delta);
        controls.moveForward(-velocity.z * delta);

        controls.getObject().position.y += velocity.y * delta;

        // Simple ground collision (y=10)
        if (controls.getObject().position.y < 10) {
          velocity.y = 0;
          controls.getObject().position.y = 10;
          canJump = true;
        }
      }

      prevTime = time;

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
